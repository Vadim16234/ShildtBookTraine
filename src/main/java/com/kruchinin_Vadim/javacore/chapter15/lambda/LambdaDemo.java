package com.kruchinin_Vadim.javacore.chapter15.lambda;

class LambdaDemo {
    public static void main(String[] args) {
        MyNumber myNum; // ябъявить ссылку на функциональный интерфейс

        // Здесь лямбда-выражение просто является константным выражением. Когда оно присваивается ссылочной переменной
        // myNum, получается экземпляр класса, в котором лямбда-выражение реализует метод getValue()
        // из функционального интерфейса MyNumber
        myNum = () -> 123.45;

        // выызвать метод getValue(), предоставляемый присвоенным ранее лямбда-выражением
        System.out.println("Фиксированное значение: " + myNum.getValue());

        // а тут используется более сложное лямбда-выражение
        myNum = () -> Math.random() * 100;

        // в следующих строках кода вызывается лямбда-выражение из предыдущей строки кода
        System.out.println("Случейное значение: " + myNum.getValue());
        System.out.println("Еще одно случейное значение: " + myNum.getValue());

        // Лямбда-выражение должно быть совместимо с абстрактным методом, определяемым в функциональном интерфейсе.
        // Поэтому следующая строка кода ошибочная
        // myNum = () -> "123.45"; // ОШИБКА!
    }
}
/*
    Как упоминалось ранее, лямбда-выражение должно быть совместимо по типу с абстрактным методом, для реализации
которого оно предназначено. Именно поэтому последняя строка кода в приведенном выше примере закомментирована.
Ведь значение типа String несовместимо с типом douЬle, возвращаемым методом getValue().
 */
